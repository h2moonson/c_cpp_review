#include <iostream>

void foo(int*& ptr) // pass pointer by reference
{
    ptr = nullptr; // 실제 ptr 인수를 변경할 수 있다.
    //NULL 포인터로 초기화된 포인터는 메모리상 어떠한 값도 가리키지 않음
    //그러나 초기화되지 않은 포인터는 어떤 값이라도 포함될 수 있고, 참조될 수 있다.
}

int main()
{
    int x = 5;
    int *ptr = &x;
    std::cout << "ptr is: " << (ptr ? "non-null" : "null") << '\n'; // prints non-null
    foo(ptr);
    std::cout << "ptr is: " << (ptr ? "non-null" : "null") << '\n'; // prints null

    return 0;
}

// ########GENERATED BY CHATGPT4o ################
/*
포인터를 참조로 전달하는 방식(`int*&`)은 C++에서 강력한 기능으로, 여러 상황에서 유용합니다. 
이 방식은 주로 함수가 인자로 전달된 포인터를 수정해야 하는 경우에 사용됩니다. 이제 이 방법이 필요한 경우와 그 장점에 대해 설명하겠습니다.

### 1. 포인터를 참조로 전달해야 하는 상황

#### **1.1 동적 메모리 할당**
동적 메모리 할당을 처리하는 함수에서 사용됩니다. 함수가 포인터를 수정하여 호출자에게 새로운 메모리를 할당해주어야 할 때 포인터를 참조로 전달합니다.

예를 들어, 동적 배열을 초기화하는 함수를 작성할 때:
*/

void allocateArray(int*& ptr, int size)
{
    ptr = new int[size]; // 메모리 할당
}

int main()
{
    int* array = nullptr;
    allocateArray(array, 10); // array 포인터가 새 메모리를 가리키도록 수정됨

    // 할당된 배열 사용
    for (int i = 0; i < 10; ++i)
    {
        array[i] = i;
    }

    delete[] array; // 동적 메모리 해제
    return 0;
}

/*
이 예제에서 `allocateArray` 함수는 포인터를 수정하여 `main` 함수에서 사용할 동적 배열을 할당합니다.
포인터를 참조로 전달함으로써, 함수 내에서 메모리 할당을 수행하고 그 결과를 호출자에게 반환할 수 있습니다.

#### **1.2 리소스 해제 및 초기화**
포인터가 동적 자원(예: 메모리, 파일 핸들)을 관리할 때, 함수가 그 포인터를 초기화하거나 자원을 해제한 후 포인터를 무효화해야 할 때 사용됩니다. 

예를 들어, 동적 메모리를 해제하고 포인터를 `nullptr`로 초기화하는 경우:

*/
void deleteArray(int*& ptr)
{
    delete[] ptr; // 동적 메모리 해제
    ptr = nullptr; // 포인터를 무효화
}

int main()
{
    int* array = new int[10];
    deleteArray(array); // 메모리 해제 및 포인터 무효화

    if (array == nullptr) {
        std::cout << "Array pointer is null\n";
    }

    return 0;
}
/*

이 예제에서, `deleteArray` 함수는 포인터를 초기화하고, 메모리를 안전하게 관리할 수 있도록 합니다. 이렇게 하면 해제된 메모리를 가리키는 포인터를 다시 사용하는 실수를 방지할 수 있습니다.

### 2. 포인터를 참조로 전달하는 장점

#### **2.1 포인터의 수정이 가능**
포인터를 참조로 전달하면 함수 내에서 인자로 전달된 포인터를 직접 수정할 수 있습니다. 이는 포인터가 가리키는 메모리 주소를 변경하거나, 
자원을 해제한 후 포인터를 `nullptr`로 설정하는 등의 작업을 가능하게 합니다.

- **함수 내에서 포인터 변경**: 포인터를 참조로 전달하면 함수 내에서 포인터가 가리키는 주소 자체를 변경할 수 있습니다. 이를 통해 함수가 포인터가 가리키는 대상을 변경할 수 있습니다.

#### **2.2 불필요한 복사를 피할 수 있음**
포인터를 참조로 전달하면 포인터의 복사가 발생하지 않으므로, 함수 호출 시 성능에 더 유리할 수 있습니다. 특히 큰 구조체나 객체를 포인터로 가리키는 경우, 
포인터의 복사는 의미가 없고 불필요합니다. 참조로 전달하면 이 복사 비용을 피할 수 있습니다.

#### **2.3 명확한 의도 표현**
코드의 의도가 명확해집니다. 포인터를 참조로 전달함으로써, 함수가 인자로 받은 포인터를 수정할 것임을 명확히 나타낼 수 있습니다. 이는 함수의 인터페이스를 이해하는 데 도움이 됩니다.

### 3. 결론

포인터를 참조로 전달하는 방식은 다음과 같은 경우에 유용합니다:

- 함수가 포인터를 수정해야 할 때.
- 동적 메모리 할당 및 해제를 처리할 때.
- 포인터의 주소를 변경하거나 초기화할 필요가 있을 때.

이 방식은 코드의 효율성을 높이고, 메모리 관리와 같은 중요한 작업에서 실수를 줄여주는 역할을 합니다. 이를 통해 더 안전하고 효율적인 C++ 코드를 작성할 수 있습니다.
*/